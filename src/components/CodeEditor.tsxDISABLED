// import React, { useCallback, useEffect, useState } from 'react';
import { FunctionalComponent } from "preact";
import { useCallback, useEffect, useState } from "preact/hooks";
// import { Loader } from 'semantic-ui-react'
import {
    Spinner,

  } from "@chakra-ui/react";
import MonacoEditor from 'react-monaco-editor'
import * as monaco from 'monaco-editor';

export interface BaseCodeProps {
    width?: string | number
    height?: string | number
    theme?: string
    language?: string
    code: string
    codeUri: monaco.Uri
    globalDeclarations?: string
    onCodeChanged?: (tsCode: string) => void
}
export interface CodeViewProps extends BaseCodeProps {
    libraries?: Record<string, string>,
    ignoreDiagnosticCodes?: number[],
}

export const CodeView: React.FC<CodeViewProps> = (props) => {
    const { onCodeChanged, code, codeUri, libraries, globalDeclarations, ignoreDiagnosticCodes } = props

    const { width, height, theme, language } = props

    const onChange = useCallback((value: string, event: monaco.editor.IModelContentChangedEvent) => {
        onCodeChanged?.(value)
    }, [onCodeChanged])

    const editorWillMount = useCallback(() => {
        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
            target: monaco.languages.typescript.ScriptTarget.ES2020,
            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
            allowNonTsExtensions: true,
            alwaysStrict: false,
        });

        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
            diagnosticCodesToIgnore: ignoreDiagnosticCodes || []
        });

        if (libraries) {
            Object.entries(libraries).forEach(([libName, libSource]) => {
                const libPath = `file:///node_modules/${libName}`;
                monaco.languages.typescript.typescriptDefaults.addExtraLib(libSource, libPath)
            })
        }

        if (globalDeclarations !== undefined) {
            monaco.languages.typescript.typescriptDefaults.addExtraLib(globalDeclarations, 'file:///global.d.ts')
        }
    }, [libraries, globalDeclarations, ignoreDiagnosticCodes])

    const model =
        monaco.editor.getModel(codeUri) ||
        monaco.editor.createModel(code, "typescript", codeUri)

    const options: monaco.editor.IStandaloneEditorConstructionOptions = {
        selectOnLineNumbers: true,
        roundedSelection: false,
        readOnly: false,
        cursorStyle: 'line',
        automaticLayout: false,
        scrollbar: {
            // Subtle shadows to the left & top. Defaults to true.
            useShadows: false,
            // Render vertical arrows. Defaults to false.
            verticalHasArrows: true,
            // Render horizontal arrows. Defaults to false.
            horizontalHasArrows: true,
            // Render vertical scrollbar.
            // Accepted values: 'auto', 'visible', 'hidden'.
            // Defaults to 'auto'
            vertical: 'visible',
            // Render horizontal scrollbar.
            // Accepted values: 'auto', 'visible', 'hidden'.
            // Defaults to 'auto'
            horizontal: 'visible',
            verticalScrollbarSize: 17,
            horizontalScrollbarSize: 17,
            arrowSize: 30,
        },
        model
    }

    return (
        <MonacoEditor
            width={width || "100%"}
            height={height || "100%"}
            language={language || "typescript"}
            theme={theme || "vs-dark"}
            value={code}
            onChange={onChange}
            editorWillMount={editorWillMount}
            options={options}
        />
    )
}

export interface CodeEditorProps extends BaseCodeProps {
    externalLibraries?: string[]
    libraries?: Record<string, string>
}

export const CodeEditor: React.FC<CodeEditorProps> = (props) => {
    const { externalLibraries, libraries, ...restProps } = props
    const [finalLibraries, setLibraries] = useState<Record<string, string>>(libraries || {})

    // fetch external libs source code
    useEffect(() => {
        let cancel = false

        const fetchLibs = async () => {
            const libs = await Promise.all((externalLibraries || []).map(async lib => {
                console.log('fetching', lib)
                const libResponse = await fetch(`${process.env.PUBLIC_URL}/${lib}`)
                const libSource = await libResponse.text()
                return ([lib, libSource])
            }))

            console.log('done fetching libs', libs)
            if (!cancel) {
                setLibraries({ ...libraries, ...Object.fromEntries(libs) })
            }
        }

        if (externalLibraries) {
            console.log('fetching libs')
            fetchLibs()
        }
        // allow cancelation to avoid state update on unmounted component
        return () => { cancel = true }
    }, [externalLibraries, libraries, setLibraries])

    if (externalLibraries && !finalLibraries) {
        return <Spinner/>
    }

    return (
        <CodeView
            {...restProps}
            libraries={finalLibraries}
            ignoreDiagnosticCodes={[
                /*top-level return*/ 1108
            ]}
        />
    )
}
