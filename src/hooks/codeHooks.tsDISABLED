import { useEffect, useState } from 'react'
import * as monaco from 'monaco-editor';
import { transpile } from "typescript";

import editorWorker from 'monaco-editor/esm/vs/editor/editor.worker?worker';
import jsonWorker from 'monaco-editor/esm/vs/language/json/json.worker?worker';
// import cssWorker from 'monaco-editor/esm/vs/language/css/css.worker?worker';
// import htmlWorker from 'monaco-editor/esm/vs/language/html/html.worker?worker';
import tsWorker from 'monaco-editor/esm/vs/language/typescript/ts.worker?worker';

export type Language = 'javascript' | 'typescript'

export interface CodeFailure {
    error: any
    phase: string
}

export interface CodeResult<R> {
    failure?: CodeFailure
    result?: R
}

export const transpileMonaco = (codeUri: monaco.Uri) => {
    const transpileInWorker = async () => {
        const tsWorkerFunc = await monaco.languages.typescript.getTypeScriptWorker()
        const tsWorker = await tsWorkerFunc(codeUri)
        const output = await tsWorker.getEmitOutput(codeUri.toString())
        const jsCode = output.outputFiles[0].text

        // Hacky, but necessary
        const exportLastIdx = jsCode.lastIndexOf('export {};')
        const finalJsCode = exportLastIdx > -1 ? jsCode.substring(0, exportLastIdx) : jsCode
        return finalJsCode
    }
    return transpileInWorker()
}

// this is (apparently) the way
const AsyncFunction = Object.getPrototypeOf(async function () { }).constructor

export const execJsCode = <R = any>(code: string, context: Record<string, any>): Promise<CodeResult<R>> => {
    let exec = null
    let args = Object.keys(context)

    try {
        // This deserves some explanation:
        // exec is a dynamically compiled function that returns a function we can call later to execute provided code.
        // This is considered the better way of doing `eval`, however, ESLint still hates it, hence we disable the warning.
        //
        // exec takes a single param 'exports', for which we provide an empty object.
        // This is because whenever you import modules in the user-provided code, the TS compiler wants to
        // define a magic property on the implicit `exports` variable to indicate the user code is also an ES module.
        // It errors out if that implicit `exports` variable is undefined.
        //
        // The returned anonymous function takes a single param `context` which we provide at execution time.
        // It's untyped since we're executing JS not TS.
        // context is used to pass whatever contextual data/functions we'd like to the user code.
        exec = AsyncFunction('exports', `"use strict"; return (async function(${args.join()}){${code}})`)({}) // eslint-disable-line
    } catch (e) {
        return Promise.resolve({ failure: { error: e, phase: 'compile' } })
    }

    if (exec) {
        var phase = 'exec'
        let values = Object.values(context)
        return exec.apply(null, values)
            .then((r: any) => ({ result: r }))
            .catch((e: any) => ({ failure: { error: e, phase } }))
    }

    return Promise.resolve({ failure: { error: 'compile failed', phase: 'compile' } })
}

export const execTsCodeMonaco = async <R = any>(codeUri: monaco.Uri, context: any): Promise<CodeResult<R>> => {
    const jsCode = await transpileMonaco(codeUri)
    return execJsCode(jsCode, context)
}

export const execTsCode = <R = any>(tsCode: string, context: any): Promise<CodeResult<R>> => {
    const jsCode = transpile(tsCode)
    return execJsCode(jsCode, context)
}

type AwaitResult<R> = { result?: R, waiting?: boolean, failure?: CodeFailure }

export function useAwait<R>(result?: R | Promise<R>): AwaitResult<R> {
    const [state, setState] = useState<AwaitResult<R>>({
        waiting: false
    })

    useEffect(() => {
        const unwrap = async (r: R | Promise<R>) => {
            if (r instanceof Promise) {
                console.debug('waiting on promise')
                setState({
                    waiting: true
                })
                try {
                    const asyncRes = await r
                    setState({
                        waiting: false,
                        result: asyncRes
                    })
                } catch (e) {
                    setState({
                        waiting: false,
                        failure: { error: e, phase: 'await' }
                    })
                }
            } else {
                setState({ result: r as R })
            }
        }
        if (result) {
            unwrap(result)
        }
    }, [result, setState])

    return state
}

export const useTransform = (args: {
    code?: string,
    context?: any,
    executionId?: number,
    skip?: boolean
}) => {
    const { context, code, executionId, skip } = args

    const [queued, setQueued] = useState<{
        ts: number,
        id?: number,
        code: string,
        context: any
    }>()

    const [executed, setExecuted] = useState<{
        ts: number,
        id?: number,
        codeResult: CodeResult<any>
    }>()

    const executedTs = executed?.ts
    const queuedTs = queued?.ts
    const pending = queuedTs !== executedTs

    useEffect(() => {
        const ts = new Date().getTime()
        if (!skip && code !== undefined && context !== undefined) {
            setQueued({
                id: executionId,
                ts, code, context
            })
        }
    }, [skip, code, context, executionId, setQueued])

    useEffect(() => {
        const execCode = async (code: string, context: any, ts: number, id?: number) => {
            const codeResult = await execTsCode(code, context)
            setExecuted({
                id, ts, codeResult,
            })
        }
        if (queued !== undefined && pending) {
            execCode(queued.code, queued.context, queued.ts, queued.id)
        }
    }, [queued, pending, setExecuted])

    const { waiting, result } = useAwait(executed?.codeResult)
    const failure = result?.failure

    return {
        loading: pending || waiting,
        errors: failure ? [`${failure.error}`] : undefined,
        result: executed?.codeResult,
        executed: executed?.id
    }
}

// https://stackoverflow.com/questions/65953675/import-monaco-editor-using-vite-2

// @ts-ignore
window.MonacoEnvironment = {
  // @ts-ignore
  getWorker(_, label) {
    if (label === 'json') {
      return new jsonWorker()
    }
    // if (label === 'css' || label === 'scss' || label === 'less') {
    //   return new cssWorker()
    // }
    // if (label === 'html' || label === 'handlebars' || label === 'razor') {
    //   return new htmlWorker()
    // }
    if (label === 'typescript' || label === 'javascript') {
      return new tsWorker()
    }
    return new editorWorker()
  }
}
